- 基本的な考え方

全ての最小項(Xなしのテストパタン)を対象に故障の最小被覆問題を解けば
完全な最小テストセットを求めることができる．

現実には全ての最小項を列挙することが無理．

案1) 故障に対するテストキューブ(Xを含んだテストパタン)を求め，
複数のテストキューブの極大両立集合を求め，それを対象に
最小被覆問題を解く．
  -> すべての極大両立集合を求めることも非現実的なので
     生成する個数に制限を加える．

案2) 故障検出関数の極大両立集合を求め，それを対象に最小被覆問題を解く．

このやり方でも厳密最小解は保証される．
ただし，全ての極大両立集合を求めることは非現実的．
なので，生成する個数に制限を加える．


案1と案2の比較
1つの故障を検出するテストキューブは唯一ではないので各故障につきテスト
キューブをひとつだけ生成した場合は厳密最小解を見逃す可能性がある．
ただし，テストキューブのマージはビットパタンの比較だけでおこなる．
生成されたテストキューブが検出する故障のチェックも故障シミュレータ
のみで行える．

故障検出関数の両立性のチェックには2つの故障を検出するコーンを追加した
DUTのCNFを用いたSAT問題を解く必要があるため，時間がかかる．
両立集合の性質から要素数nの両立性のチェックにはn個の故障を検出する
コーンを追加したDUTのCNFを用いたSAT問題を解く必要があり，時間とメモリ
がかかる．

案3) 故障検出関数を必要割り当て(拡張テストキューブ)で代用する．
両立チェックはSAT問題を解く必要があるが，常にDUTのCNFでよい．


案1の実装

各故障に対してテストキューブを求める．
複数求める場合は求めたテストキューブを否定した節を追加する．
ので，故障ごとに異なるSATソルバを作る．

以降はSATソルバを使わない．

求まったテストキューブの極大両立集合を列挙する．
具体的には Taboo search を用いる．

signature = "---------" 全部ドントケア
for N times {
  signature に基づいた極大集合を求める．
  重複していなかったら登録する．

  signature の中からもっとも価値の低いビットを求める．
  そのビットをドントケアに変える．
  そのビットをタブーリストに入れる．
}

データ構造としてはビットごとにコンフリクトしているキューブのリストを持
って置く．
signature のビットを固定する際にはそのビットとコンフリクトしているキュー
ブの少ないビットを選ぶようにする．

signature のビットをドントケアに戻す際にはそのビットを除くことでコンフ
リクトしているキューブさ最小となるビットを選ぶ．

現行の TvMerger がほぼこれを実装している．
あとはタイブレーカーをランダムにすることくらい．


案2の実装

- コンフリクト/両立の判断:
  f1 の検出用コーンと f2 の検出用コーンを追加した回路のCNF
  が SAT なら両立，UNSAT ならコンフリクト

  f1, f2, ..., fn の検出用コーンを追加した回路の CNF
  が SAT なら両立，UNSAT ならコンフリクト

- スクリーニングとして下の案3の判定が使える．

案3の実装

各故障に対して十分割り当てと必要割り当てを求める．

- コンフリクトの判断:
  f1 の必要割り当てと f2 の必要割り当ての両方を assume して UNSAT
  ならコンフリクト

  f1, f2, ... fn の必要割り当ての全てを assume して UNSAT
  ならコンフリクト

- 両立の判断:
  f1 の十分割り当てと f2 の十分割り当ての両方を assume して SAT
  なら両立

  f1, f2, ..., fn の十分割り当ての全てを assume して SAT
  なら両立


どの場合でも対象となる故障が少ないほうがよいので故障支配による
縮約を厳密に行う．

故障シミュレーションを用いたスクリーニング

- f1 が未検出，f2 が検出，というパタンが現れない場合，f1 が f2 を支配
  している可能性がある．

  * 概念的には 故障 x 故障 の2次元配列を作り，故障シミュレーションの結
    果， (検出，未検出) となったペアを消してゆけばよい．
  * 残ったペアは (支配，被支配) の候補ペアとなる．
  * 問題は O(N^2) の時間・空間複雑度となること．
  * -> ZDD を使ってこの2項関係を表す．

- 同一 FFR 内の故障．
  * FFRの根からの故障検出条件は同一なので，FFR内の故障検出条件の違いを
  見れば良い．

  * 具体的には FFR の根からの故障検出条件を CR, f1 のFFR内の故障検出条
    件を C1, f2 の FFR内の故障検出条件を C2 とすると，

    CR & C1 & ~C2 が UNSAT の時に f2 が f1 を支配している．
    つまり，f2 を検出するパタンは常に f1 も検出できる．

  * 問題は ~C2 を表す条件は複数のCNF節となるため，単純な実装では，毎回，
    異なるSATソルバーを作る必要があるということ．
    そこで，故障ごとに新たな制御変数 ci を用意して，ci = 1 の時のみ
    条件 ~Ci がアクティベイトするようにする．

  * 現行の FaultReducer がほぼこのような実装になっている．
